{"ast":null,"code":"import { getAuth, onAuthStateChanged } from 'firebase/auth';\nimport { ref, get, set, update } from 'firebase/database';\nimport { db } from \"../backend/firebase\";\nconst readCurrentUserData = () => {\n  return new Promise((resolve, reject) => {\n    const auth = getAuth();\n    const unsubscribe = onAuthStateChanged(auth, user => {\n      if (user) {\n        console.log(\"ENTER readCurrentUserData - User authenticated\");\n        resolve(user.uid);\n      } else {\n        console.log(\"ENTER readCurrentUserData - User not authenticated\");\n        reject(new Error(\"User not authenticated\"));\n      }\n      // Don't forget to unsubscribe when done.\n      unsubscribe();\n    });\n  });\n};\n\n// For new sign-ups and updating of balance\nconst writePlayerData = async (email, balance, deck, isNew = true) => {\n  const auth = getAuth();\n  try {\n    const user = await readCurrentUserData();\n    const dataLocation = \"players\";\n    const reference = ref(db, `${dataLocation}/${user}/`);\n    const snapshot = await get(reference);\n    if (snapshot.exists() && isNew) {\n      console.log(\"Invalid id: id already exists in Data\");\n      // You can handle this case as needed, e.g., throw an error\n      throw new Error(\"Invalid id: id already exists in Data\");\n    } else {\n      console.log(\"NEW writePlayerData\");\n      if (isNew) {\n        await set(ref(db, `${dataLocation}/${user}/`), {\n          email,\n          balance: 1000,\n          deck\n        });\n      } else {\n        // We update instead\n        await update(ref(db, `players/${user}/`), {\n          email,\n          balance,\n          deck\n        });\n      }\n      return user; // Return user.uid on success\n    }\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n    // Handle the error as needed\n    throw error;\n  }\n};\nconst writeDeckData = async deck => {\n  const auth = getAuth();\n  try {\n    const user = await readCurrentUserData();\n    const dataLocation = \"players\";\n    const reference = ref(db, `${dataLocation}/${user}/`);\n    const snapshot = await get(reference);\n    if (snapshot.exists()) {\n      await update(ref(db, `players/${user}/`), {\n        deck\n      });\n    }\n    return user; // Return user.uid on success\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n    // Handle the error as needed\n    throw error;\n  }\n  ;\n};\nconst writeBalanceData = async balance => {\n  const auth = getAuth();\n  try {\n    const user = await readCurrentUserData();\n    const dataLocation = \"players\";\n    const reference = ref(db, `${dataLocation}/${user}/`);\n    const snapshot = await get(reference);\n    if (snapshot.exists()) {\n      await update(ref(db, `players/${user}/`), {\n        email,\n        balance: snapshot.val().balance + 1000,\n        deck\n      });\n    }\n    return user; // Return user.uid on success\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n    // Handle the error as needed\n    throw error;\n  }\n};\nexport { writePlayerData, readCurrentUserData, writeDeckData, writeBalanceData };","map":{"version":3,"names":["getAuth","onAuthStateChanged","ref","get","set","update","db","readCurrentUserData","Promise","resolve","reject","auth","unsubscribe","user","console","log","uid","Error","writePlayerData","email","balance","deck","isNew","dataLocation","reference","snapshot","exists","error","message","writeDeckData","writeBalanceData","val"],"sources":["/Users/carlintan/Desktop/banluck888/src/backend/command.js"],"sourcesContent":["import { getAuth, onAuthStateChanged } from 'firebase/auth';\nimport { ref, get, set, update } from 'firebase/database';\nimport { db } from \"../backend/firebase\";\n\nconst readCurrentUserData = () => {\n    return new Promise((resolve, reject) => {\n        const auth = getAuth();\n        const unsubscribe = onAuthStateChanged(auth, (user) => {\n            if (user) {\n                console.log(\"ENTER readCurrentUserData - User authenticated\");\n                resolve(user.uid);\n            } else {\n                console.log(\"ENTER readCurrentUserData - User not authenticated\");\n                reject(new Error(\"User not authenticated\"));\n            }\n            // Don't forget to unsubscribe when done.\n            unsubscribe();\n        });\n    });\n};\n\n// For new sign-ups and updating of balance\nconst writePlayerData = async (\n    email,\n    balance,\n    deck,\n    isNew = true\n) => {\n    const auth = getAuth();\n\n    try {\n        const user = await readCurrentUserData();\n\n        const dataLocation = \"players\";\n        const reference = ref(db, `${dataLocation}/${user}/`);\n\n        const snapshot = await get(reference);\n\n        if (snapshot.exists() && isNew) {\n            console.log(\"Invalid id: id already exists in Data\");\n            // You can handle this case as needed, e.g., throw an error\n            throw new Error(\"Invalid id: id already exists in Data\");\n        } else {\n            console.log(\"NEW writePlayerData\");\n            if (isNew) {\n                await set(ref(db, `${dataLocation}/${user}/`), {\n                    email,\n                    balance: 1000,\n                    deck,\n                });\n            } else {\n                // We update instead\n                await update(ref(db, `players/${user}/`), {\n                    email,\n                    balance,\n                    deck,\n                });\n            }\n            return user; // Return user.uid on success\n        }\n    } catch (error) {\n        console.error(\"Error:\", error.message);\n        // Handle the error as needed\n        throw error;\n    }\n};\n\nconst writeDeckData = async (\n    deck,\n) => {\n    const auth = getAuth();\n\n    try {\n        const user = await readCurrentUserData();\n\n        const dataLocation = \"players\";\n        const reference = ref(db, `${dataLocation}/${user}/`);\n\n        const snapshot = await get(reference);\n\n        if (snapshot.exists()) {\n            await update(ref(db, `players/${user}/`), {\n                deck,\n            });\n        }\n        return user; // Return user.uid on success\n    }\n    catch (error) {\n        console.error(\"Error:\", error.message);\n        // Handle the error as needed\n        throw error;\n    };\n}\n\nconst writeBalanceData = async (\n    balance\n) => {\n    const auth = getAuth();\n\n    try {\n        const user = await readCurrentUserData();\n\n        const dataLocation = \"players\";\n        const reference = ref(db, `${dataLocation}/${user}/`);\n\n        const snapshot = await get(reference);\n\n        if (snapshot.exists()) {\n            await update(ref(db, `players/${user}/`), {\n                email,\n                balance: snapshot.val().balance + 1000,\n                deck,\n            });\n        }\n        return user; // Return user.uid on success\n    } catch (error) {\n        console.error(\"Error:\", error.message);\n        // Handle the error as needed\n        throw error;\n    }\n};\n\nexport {\n    writePlayerData,\n    readCurrentUserData,\n    writeDeckData,\n    writeBalanceData\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}